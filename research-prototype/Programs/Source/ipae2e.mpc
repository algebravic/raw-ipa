import os

from Compiler.library import print_ln, for_range
from Compiler.types import sint, Matrix, Array


numrows_power = int(os.getenv('IPA_NUMROWS_POWER', 10))
numrows = 2 ** numrows_power

verbose = os.getenv('IPA_VERBOSE', None)
if verbose is not None:
    if verbose == 'True':
        verbose = True
    elif verbose == 'False':
        verbose = False
    else:
        raise Exception(f"Unknown verbose value: {verbose}")
else:
    verbose = False

print_ln('********************  IPA E2E %s **********************', numrows)

_list = Matrix(numrows, 4, sint)

local_params = {
    '_list': _list,
    'sint': sint,
    'print_ln': print_ln,
}

for i in range(numrows):
    for j in range(3):
        cmd = f"_list[{i}][{j}] = sint.get_input_from(0)"
        exec(cmd, {}, local_params)

# Radix sort
_list.sort((0,), n_bits=32)

if verbose:
    for i in range(numrows):
        cmd = (f"print_ln('%s, %s, %s, %s', "
               f"_list[{i}][0].reveal(), _list[{i}][1].reveal(),"
               f"_list[{i}][2].reveal(), _list[{i}][3].reveal(),)")
        exec(cmd, {}, local_params)

helperbit = Array(numrows, sint)
local_params['helperbit'] = helperbit

for i in range(numrows-1):
    cmd = f"helperbit[{i}] = (_list[{i}][0] == _list[{i}+1][0]).if_else(1, 0)"
    exec(cmd, {}, local_params)


helperbit_and_istrigger = Array(numrows, sint)
local_params['helperbit_and_istrigger'] = helperbit_and_istrigger
helperbit_xor_istrigger = Array(numrows, sint)
local_params['helperbit_xor_istrigger'] = helperbit_xor_istrigger

for i in range(numrows-1):
    cmd = f"helperbit_and_istrigger[{i}] = helperbit[{i}] * _list[{i}][1]"
    exec(cmd, {}, local_params)
    cmd = f"helperbit_xor_istrigger[{i}] = (helperbit[{i}] + _list[{i}][1]) % 2"
    exec(cmd, {}, local_params)

if verbose:
    print_ln('%s', helperbit.reveal())
    print_ln('%s', helperbit_and_istrigger.reveal())
    print_ln('%s', helperbit_xor_istrigger.reveal())


stopbits = [Array(numrows, sint) for _ in range(numrows_power+1)]

for stopbit in stopbits:
    local_params['stopbit'] = stopbit
    for i in range(numrows):
        cmd = f"stopbit[{i}] = 1"
        exec(cmd, {}, local_params)

credits = [Array(numrows, sint) for _ in range(numrows_power+1)]
local_params['credits'] = credits

for i, (stopbit, credit) in enumerate(zip(stopbits, credits)):
    stepsize = 2 ** i
    local_params['stopbit'] = stopbit
    local_params['credit'] = credit
    local_params['stepsize'] = stepsize

    for current in range(numrows - stepsize):
        successor = current + stepsize
        # can remove stopbit1[current] since will always be 1
        # another optimization could be to multiply one time all the
        # helperbit * istrigger bits since these are fixed.

        cmd = f"flag = helperbit_and_istrigger[{successor}];"
        # credit is initialized to value, _list[i][2] = value[i]
        cmd += f"credit[{current}] = _list[{current}][2] + flag * _list[{successor}][2];"

        # * stopbit[successor]  stopbit[successor] here would always be 1 so can drop
        cmd += f"stopbit[{current}] = flag"
        exec(cmd, {}, local_params)

    if verbose:
        print_ln('iteration: %s', i)
        print_ln('%s', credit.reveal())
        print_ln('%s', stopbit.reveal())

if verbose:
    print_ln("credits[-1]:")
    for i, credit in enumerate(credits[::-1]):
        print_ln('%s', credit[i].reveal())


# I can't sum all of credit, I need to sum only those that correspond to last touches
# helperbit_xor_istrigger * credits[-1] will give this.
creditfinal = Array(numrows, sint)
local_params['creditfinal'] = creditfinal

for i in range(numrows):
    cmd = f"creditfinal[{i}] = helperbit_xor_istrigger[{i}] * credits[-1][{i}]"
    exec(cmd, {}, local_params)

if verbose:
    print_ln("creditfinal:")
    for c in creditfinal:
        print_ln("%s", c.reveal())

# SUM BREAKDOWNS
breakdowns = 4

bksums = [
    [Array(2 ** i, sint) for i in range(numrows_power, 0, -1)]
    for _ in range(breakdowns)
]
local_params['bksums'] = bksums

bkfinalsums = [sint(0) for _ in range(breakdowns)]
local_params['bkfinalsums'] = bkfinalsums

for bksum in bksums:
    local_params['bksum'] = bksum
    for i in range(numrows//2):
        # key =1
        cmd = (
            f"bksum[0][{i}] = bksum[0][{i}] + "
            f"(_list[{2*i}][3] == 1).if_else(creditfinal[{2*i}], 0) + "
            f"(_list[{2*i+1}][3] == 1).if_else(creditfinal[{2*i+1}], 0)"
        )
        exec(cmd, {}, local_params)

    for j, _bksum in enumerate(bksum[1:]):
        local_params['_bksum'] = _bksum
        for i in range(numrows//2**(j+2)):
            k = 2*i
            cmd = f"_bksum[{i}] = _bksum[{k}] + _bksum[{k+1}]"
            exec(cmd, {}, local_params)

for i, bkfinalsum in enumerate(bkfinalsums):
    cmd = f"bkfinalsum = bksums[{i}][-1][0] + bksums[{i}][-1][1]"
    exec(cmd, {}, local_params)

print_ln(
    "breakdowns = %s, %s, %s, %s",
    bkfinalsums[0].reveal(),
    bkfinalsums[1].reveal(),
    bkfinalsums[2].reveal(),
    bkfinalsums[3].reveal()
)
