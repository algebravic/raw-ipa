numrows_power = 10
numrows = 2 ** numrows_power

print_ln('********************  IPA E2E %s **********************', numrows)

_list = Matrix(numrows, 4, sint)

@for_range(numrows)
def _(i):
    _list[i][0] = sint.get_input_from(0)  # matchkey
    _list[i][1] = sint.get_input_from(0)  # istrigger
    _list[i][2] = sint.get_input_from(0)  # value
    _list[i][3] = sint.get_input_from(0)  # breakdown


# Radix sort
_list.sort((0,), n_bits=32)

for i in range(numrows):
    print_ln(
        '%s, %s, %s, %s',
        _list[i][0].reveal(),
        _list[i][1].reveal(),
        _list[i][2].reveal(),
        _list[i][3].reveal(),
    )

helperbit = Array(numrows, sint)
@for_range(numrows-1)
def _(i):
    helperbit[i] = (_list[i][0] == _list[i+1][0]).if_else(1,0)


helperbit_and_istrigger = Array(numrows, sint)
helperbit_xor_istrigger = Array(numrows, sint)


@for_range(numrows-1)
def _(i):
    helperbit_and_istrigger[i] = helperbit[i] * _list[i][1]
    helperbit_xor_istrigger[i] = (helperbit[i] + _list[i][1]) % 2


print_ln('%s', helperbit.reveal())
print_ln('%s', helperbit_and_istrigger.reveal())
print_ln('%s', helperbit_xor_istrigger.reveal())


stopbits = [Array(numrows, sint) for _ in range(numrows_power+1)]

for stopbit in stopbits:
    @for_range(numrows)
    def __(i):
        stopbit[i] = 1

credits = [Array(numrows, sint) for _ in range(numrows_power+1)]


for i, (stopbit, credit) in enumerate(zip(stopbits, credits)):
    stepsize = 2 ** i
    @for_range(numrows - stepsize)
    def __(current):
        successor = current + stepsize
        flag = helperbit_and_istrigger[successor]  # can remove stopbit1[current] since will always be 1   #another optimization could be to multiply one time all the helperbit * istrigger bits since these are fixed.
        credit[current] = _list[current][2] + flag * _list[successor][2]  #credit is initialized to value, _list[i][2] = value[i]
        stopbit[current] = flag # * stopbit[successor]  stopbit[successor] here would always be 1 so can drop

    print_ln('iteration: %s', i)
    print_ln('%s', credit.reveal())
    print_ln('%s', stopbit.reveal())

print_ln("credits[-1]:")
for i, credit in enumerate(credits[::-1]):
    print_ln('%s', credit[i].reveal())


# I can't sum all of credit, I need to sum only those that correspond to last touches
# helperbit_xor_istrigger * credits[-1] will give this.

creditfinal = Array(numrows,sint)

@for_range(numrows)
def _(i):
    creditfinal[i] = helperbit_xor_istrigger[i] * credits[-1][i]

print_ln("creditfinal:")
for c in creditfinal:
    print_ln("%s", c.reveal())



# SUM BREAKDOWNS
breakdowns = 4

bksums = [
    [Array(2 ** i, sint) for i in range(numrows_power, 0, -1)]
    for _ in range(breakdowns)
]

bkfinalsums = [sint(0) for _ in range(breakdowns)]


for bksum in bksums:
    @for_range(numrows//2)
    def _(i):
        bksum[0][i] = bksum[0][i] + (_list[2*i][3] == 1).if_else( creditfinal[2*i], 0) + (_list[2*i+1][3] == 1).if_else( creditfinal[2*i+1], 0) #key =1

    for j, _bksum in enumerate(bksum[1:]):
        @for_range(numrows//2**(j+2))
        def _(i):
            k = 2*i
            _bksum[i] = _bksum[k] + _bksum[k+1]


for i, bkfinalsum in enumerate(bkfinalsums):
    bkfinalsum = bksums[i][-1][0] + bksums[i][-1][1]

print_ln("breakdowns = %s, %s, %s, %s",bkfinalsums[0].reveal(),bkfinalsums[1].reveal(),bkfinalsums[2].reveal(),bkfinalsums[3].reveal())
