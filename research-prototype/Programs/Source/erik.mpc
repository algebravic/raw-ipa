"""
Rewriting Erik's mpc files using vectors
"""
import argparse
import os
import sys
from typing import Optional
from pathlib import Path
from Compiler import types, library, instructions, sorting

VALUE = 0
IS_TRIGGER = 1
BREAKDOWN_KEY = 2

def set_directory() -> None:

    source_dir = os.getcwd() + '/Programs/Source'
    sys.path = [source_dir] + sys.path

def reconstruct(bit_array: Matrix) -> Array:
    """
    bit_array is an N by B array of bits
    compute the integer representation.
    This should only involve scalar multiplies and adds.
    """

    num, n_bits = bit_array.sizes
    result = Array(num, sint)
    result.assign_vector(bit_array.get_column(n_bits - 1))
    for ind in range(n_bits - 2, -1, -1):
        result = result + result + bit_array.get_column(ind)
    return result

def get_args(args) -> argparse.Namespace:
    """
    Get the arguments from the remainder of compile.py command line.
    """

    # It turns out that you *can* get arguments from the compile.py
    # command.  The arguments are everything after the name
    # of the file to be compiled.

    arg_parser = argparse.ArgumentParser("Attribution Benchmark")
    arg_parser.add_argument("numrows_power", type=int, default = 12,
                            nargs = '?',
                            help="Power of 2 for number of Rows")
    arg_parser.add_argument("breakdown_values", type = int, default = 4,
                            nargs = '?',
                            help="Calculate Breakdown?")
    arg_parser.add_argument("n_bits", type = int, default = 32,
                            nargs = '?',
                            help="n_bits?")
    arg_parser.add_argument("have_bits", type = int, default = 0,
                            nargs = '?',
                            help="Match keys are a bit array")
    arg_parser.add_argument("do_sort", type = int, default = 1,
                            nargs = '?',
                            help="Sort the match keys")
    return arg_parser.parse_args(args)

# Do this where the columns are separate
# This will allow us to use match_keys as a bit array
def oblivious_attribution(match_keys: Array,
                          reports: Matrix,
                          breakdown_values: int) -> Optional[Array]:
    """
    Perform the oblivious attribution.
    """

    assert len(match_keys) == len(reports)
    numrows, _  = reports.sizes

    # Edge cases: imagine that the match-keys are extended at either
    # end with keys that are different than any of the real keys
    # That means that helperbits[0] = 0
    # and that stopbits at the end are zeroed out
    helperbits = Array(numrows, sint)
    helperbits.assign_vector(match_keys.get_vector(size = numrows - 1)
                             == match_keys.get_vector(base = 1,
                                                      size = numrows - 1),
                             base = 1)
    helperbits[0] = 0
    # helperbits[idx] = True if there's a transition to a new match key

    # is_trigger[idx] = True means this is a trigger even
    # we want to match all non-trigger events (i.e. source events)
    # with trigger events with the same matchkey

    is_trigger = reports.get_column(IS_TRIGGER)
    helperbits_and_istrigger = helperbits * is_trigger.get_vector()
    
    # I think that the exponent refers to the depth in a binary tree.

    # It looks like this is just a binary tree sum


    # I guess that this is supposed to be last touch attribution
    #
    # Prepare
    # Problem: stopbit is the wrong size.

    # Initialize for results after the first pass
    stopbit = Array(numrows, sint)
    credit = Array(numrows, sint)
    repval = reports.get_column(VALUE)

    stopbit.assign_vector(helperbits_and_istrigger.get_vector(base = 1,
                                                              size = numrows - 1))
    stopbit[numrows - 1] = 0
    credit[numrows - 1] = repval[numrows - 1]

    credit.assign_vector(repval.get_vector(size = numrows - 1)
                         + stopbit.get_vector(size = numrows - 1)
                         * repval.get_vector(base = 1,
                                             size = numrows - 1))
    
    zeros = Array(numrows // 2, sint)
    zeros.assign_all(0)

    stepsize = 1

    while stepsize < numrows // 2:

        # inc(size, base, step, repeat)
        # produces a regint vector like range(base, size // step, step)
        # get method takes an array of regints and produces the
        # vector indexed by them,

        # flag = helperbits_and_istrigger{stepsize:]
        # credit = reports[: -stepsize][VALUE] + flag * reports[stepsize: ][VALUE]
        stepsize *= 2

        new_size = numrows - stepsize

        flag = (stopbit.get_vector(size = new_size)
                * helperbits_and_istrigger.get_vector(base = stepsize,
                                                     size = new_size))
        new_credit = (credit.get_vector(size = new_size)
                      + flag
                      * credit.get_vector(base = stepsize,
                                          size = new_size))
        stopbit.assign_vector(flag
                              * stopbit.get_vector(base = stepsize,
                                                   size = new_size))
        # Now 0 out the last stepsize stopbit's
        # stopbit.get_vector(base = new_size, size = stepsize).assign_all(0)
        stopbit.assign_vector(zeros.get_vector(size = stepsize),
                              base = new_size)
            
        credit.assign_vector(new_credit)

    # Calculate final_credits
    if breakdown_values:

        breakdown = reports.get_column(BREAKDOWN_KEY)

        # Once we have AND, XOR is just addition and subtraction

        helperbits_xor_istrigger = (helperbits
                                    + is_trigger.get_vector()
                                    - helperbits_and_istrigger)

        final_credits = helperbits_xor_istrigger * credit
        
        breakdown_keys = list(range(breakdown_values))

        breakdown_key_sums = Array(breakdown_values, sint)

        for breakdown_key in breakdown_keys:

            # max[idx] = 1 if breakdown[idx] == breakdown_key, 0 otherwise
            mask = breakdown == breakdown_key
            # Sum up the final_credits for this breakdown
            # We can do this with sum, but tree_reduce is more efficient.
            breakdown_key_sums[breakdown_key] = tree_reduce(lambda x,y: x + y,
                                                            mask * final_credits)
            return breakdown_key_sums

        return None

def main():
    """
    Do the main processing.
    """

    set_directory()
    from bsort import bit_radix_sort, new_radix_sort
    args = get_args(program.args[1: ])
    print(f"args = {args}")

    numrows = 2 ** args.numrows_power

    # load the data
    print(f"Using {'bits' if args.have_bits else 'sint'}")
    match_keys = Array(numrows, sint)
    
    match_bits = Matrix(numrows, args.n_bits, sint)
    if args.have_bits:
        match_bits.assign_vector(
            sint.get_input_from(0, size = numrows * args.n_bits))
        match_keys.assign_vector(reconstruct(match_bits))
    else:
        print('*** No bits ***')
        match_keys.assign_vector(sint.get_input_from(0, size = numrows))

    reports = Matrix(numrows, 3, sint)
    reports.assign_vector(sint.get_input_from(0, size = numrows * 3))

    # Now do the sort
    # Radix sort
    print(f"***** # match_keys = {len(match_keys)}")
    if args.do_sort:

        if args.have_bits:
            bit_radix_sort(match_bits, reports)
        else:
        
            new_radix_sort(match_keys, reports,
                               n_bits = args.n_bits)

    breakdown_key_sums = oblivious_attribution(match_keys, reports,
                                               args.breakdown_values)

    if breakdown_key_sums is not None:
        print_ln("breakdowns: %s", breakdown_key_sums.reveal())
    
main()

