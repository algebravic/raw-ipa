"""
Rewriting Erik's mpc files using vectors
"""
import argparse
import os
import sys
from typing import Optional
from pathlib import Path
from Compiler import types, library, instructions, sorting

MATCH_KEYS = 0
VALUE = 2
IS_TRIGGER = 1
BREAKDOWN_KEY = 3

RADIX_SORT = 0
BIT_RADIX_SORT = 1
BATCHER_SORT = 2
LIBRARY_SORT = 3

def set_directory() -> None:

    source_dir = os.getcwd() + '/Programs/Source'
    sys.path = [source_dir] + sys.path

def get_args(args) -> argparse.Namespace:
    """
    Get the arguments from the remainder of compile.py command line.
    """

    # It turns out that you *can* get arguments from the compile.py
    # command.  The arguments are everything after the name
    # of the file to be compiled.

    arg_parser = argparse.ArgumentParser("Attribution Benchmark")
    arg_parser.add_argument("numrows_power", type=int, default = 12,
                            nargs = '?',
                            help="Power of 2 for number of Rows")
    arg_parser.add_argument("breakdown_values", type = int, default = 4,
                            nargs = '?',
                            help="Calculate Breakdown?")
    arg_parser.add_argument("n_bits", type = int, default = 32,
                            nargs = '?',
                            help="n_bits?")
    arg_parser.add_argument("sort_type", type = int,
                            default = LIBRARY_SORT,
                            nargs = '?',
                            help="sort_type")
    arg_parser.add_argument("do_sort", type = int, default = 1,
                            nargs = '?',
                            help="Sort the match keys")
    return arg_parser.parse_args(args)

def oblivious_attribution(reports: Matrix,
                          breakdown_values: int) -> Array:
    """
    Perform the oblivious attribution.
    """

    numrows, _  = reports.sizes

    # Edge cases: imagine that the match-keys are extended at either
    # end with keys that are different than any of the real keys
    # That means that helperbits[0] = 0
    # and that stopbits at the end are zeroed out
    helperbits = Array(numrows, sint)

    @for_range_opt(numrows - 1)
    def _(ind):
        helperbits[ind] = (reports[ind][MATCH_KEYS]
                           == reports[ind + 1][MATCH_KEYS])

    helperbits[0] = 0

    # helperbits[idx] = True if there's a transition to a new match key

    # is_trigger[idx] = True means this is a trigger even
    # we want to match all non-trigger events (i.e. source events)
    # with trigger events with the same matchkey
    helperbits_and_istrigger = Array(numrows, sint)

    @for_range_opt(numrows)
    def _(ind):
        helperbits_and_istrigger[ind] = (helperbits[ind]
                                         * reports[ind][IS_TRIGGER])
    stopbit = Array(numrows, sint)
    credit = Array(numrows, sint)
    
    @for_range_opt(numrows - 1)
    def _(ind):
        stopbit[ind] = helperbits_and_istrigger[ind + 1]

    stopbit[numrows - 1] = 0

    @for_range_opt(numrows - 1)
    def _(ind):
        credit[ind] = (reports[ind][VALUE] +
                       stopbit[ind] * reports[ind + 1][VALUE])

    credit[numrows - 1] = reports[numrows - 1][VALUE]

    stepsize = 1
    flag = Array(numrows, sint)
    new_credit = Array(numrows, sint)

    while stepsize < numrows // 2:

        # inc(size, base, step, repeat)
        # produces a regint vector like range(base, size // step, step)
        # get method takes an array of regints and produces the
        # vector indexed by them,

        # flag = helperbits_and_istrigger{stepsize:]
        # credit = reports[: -stepsize][VALUE] + flag * reports[stepsize: ][VALUE]
        stepsize *= 2

        new_size = numrows - stepsize

        @for_range_opt(new_size)
        def _(ind):
            flag = stopbit[ind] * helperbits_and_istrigger[ind + stepsize]

            new_credit[ind] = (credit[ind] + flag
                               * credit[ind + stepsize])

            stopbit[ind] = flag * stopbit[ind + stepsize]

        @for_range_opt(stepsize)
        def _(ind):
            stopbit[ind + new_size] = 0

        @for_range_opt(new_size)
        def _(ind):
            credit[ind] = new_credit[ind]

    # Once we have AND, XOR is just addition and subtraction

    helperbits_xor_istrigger = Array(numrows, sint)
    # Note if x,y are 0/1 valued then
    # x XOR y = x + y - 2 * x*y
    @for_range_opt(numrows)
    def _(ind):
        helperbits_xor_istrigger[ind] = (helperbits[ind] +
                                         reports[ind][IS_TRIGGER]
                                         -2 * helperbits_and_istrigger[ind])

    final_credits = Array(numrows, sint)
    
    @for_range_opt(numrows)
    def _(ind):
        final_credits[ind] = helperbits_xor_istrigger[ind] * credit[ind]

    breakdown_key_sums = Array(breakdown_values, sint)

    for breakdown_key in range(breakdown_values):
        result = sint(0)

        @for_range(numrows)
        def _(ind):
            mask = reports[ind][BREAKDOWN_KEY] == breakdown_key
            contrib = mask * final_credits[ind]
            global result
            result += contrib

        breakdown_key_sums[breakdown_key] = result
    return breakdown_key_sums

def main():
    """
    Do the main processing.
    """

    set_directory()
    from asort import bit_radix_sort, radix_sort
    args = get_args(program.args[1: ])
    print(f"args = {args}")

    numrows = 2 ** args.numrows_power

    # load the data

    reports = Matrix(numrows, 4, sint)
    @for_range_opt(numrows)
    def _(ind):
        reports[ind][MATCH_KEYS] = sint.get_input_from(0)
        reports[ind][IS_TRIGGER] = sint.get_input_from(0)
        reports[ind][VALUE] = sint.get_input_from(0)
        reports[ind][BREAKDOWN_KEY] = sint.get_input_from(0)

    # Now do the sort

    sorter = {LIBRARY_SORT: lambda mkeys, reps:
              sorting.radix_sort(mkeys, reports, n_bits = args.n_bits),
              RADIX_SORT: lambda mkeys, reps:
              radix_sort(mkeys, reps, n_bits = args.n_bits),
              BATCHER_SORT: lambda mkeys, reps:
              print("Batcher not implemented")}

    if args.do_sort:

        sort_fn = sorter.get(args.sort_type,
                             lambda mkeys, reps:
                             print(f"Illegal sort type {args.sort_type}"))
        sort_fn(reports.get_column(MATCH_KEYS), reports)

    breakdown_key_sums = oblivious_attribution(reports,
                                               args.breakdown_values)

    print_ln("breakdowns: %s", breakdown_key_sums.reveal())
    
main()

