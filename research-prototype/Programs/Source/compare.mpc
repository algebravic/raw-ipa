"""
Rewriting Erik's mpc files using vectors
"""
import argparse
import os
import sys
from typing import Optional
from pathlib import Path
from Compiler import types, library, instructions, sorting

MATCH_KEYS = 0
VALUE = 2
IS_TRIGGER = 1
BREAKDOWN_KEY = 3

RADIX_SORT = 0
BIT_RADIX_SORT = 1
BATCHER_SORT = 2
LIBRARY_SORT = 3

def set_directory() -> None:

    source_dir = os.getcwd() + '/Programs/Source'
    sys.path = [source_dir] + sys.path

def reconstruct(bit_array: Matrix) -> Array:
    """
    bit_array is an N by B array of bits
    compute the integer representation.
    This should only involve scalar multiplies and adds.
    """

    num, n_bits = bit_array.sizes
    result = Array(num, sint)
    result.assign_vector(bit_array.get_column(n_bits - 1))
    for ind in range(n_bits - 2, -1, -1):
        result = result + result + bit_array.get_column(ind)
    return result

def get_args(args) -> argparse.Namespace:
    """
    Get the arguments from the remainder of compile.py command line.
    """

    # It turns out that you *can* get arguments from the compile.py
    # command.  The arguments are everything after the name
    # of the file to be compiled.

    arg_parser = argparse.ArgumentParser("Attribution Benchmark")
    arg_parser.add_argument("numrows_power", type=int, default = 12,
                            nargs = '?',
                            help="Power of 2 for number of Rows")
    arg_parser.add_argument("breakdown_values", type = int, default = 4,
                            nargs = '?',
                            help="Calculate Breakdown?")
    arg_parser.add_argument("n_bits", type = int, default = 32,
                            nargs = '?',
                            help="n_bits?")
    arg_parser.add_argument("sort_type", type = int,
                            default = LIBRARY_SORT,
                            nargs = '?',
                            help="sort_type")
    arg_parser.add_argument("do_sort", type = int, default = 1,
                            nargs = '?',
                            help="Sort the match keys")
    return arg_parser.parse_args(args)

def oblivious_attribution(reports: Matrix,
                          breakdown_values: int) -> Array:
    """
    Perform the oblivious attribution.
    """

    numrows, _  = reports.sizes

    # Edge cases: imagine that the match-keys are extended at either
    # end with keys that are different than any of the real keys
    # That means that helperbits[0] = 0
    # and that stopbits at the end are zeroed out
    helperbits = Array(numrows, sint)

    @for_range_opt(numrows - 1)
    def _(ind):
        helperbits[ind] = reports[ind][MATCH_KEYS] == reports[ind + 1][MATCH_KEYS]

    helperbits[0] = 0
    # helperbits[idx] = True if there's a transition to a new match key

    # is_trigger[idx] = True means this is a trigger even
    # we want to match all non-trigger events (i.e. source events)
    # with trigger events with the same matchkey
    helperbits_and_istrigger = Array(numrows, sint)

    @for_range_opt
    def _(ind):
        helperbits_and_istrigger[ind] = helperbits[ind] * reports[ind][ IS_TRIGGER]

    # Prepare

    stopbit = Array(numrows, sint)
    credit = Array(numrows, sint)
    
    @for_range_opt(numrows - 1)
    def _(ind):
        stopbit[ind] = helperbits_and_istrigger[i + 1]

    stopbit[numrows - 1] = 0

    @for_range_opt(numrows - 1)
    def _(ind):
        credit[ind] = (reports[ind, VALUE] +
                       stopbit[ind] * reports[ind + 1, VALUE])
    credit[numrows - 1] = reports[numrows - 1, VALUE]

    stepsize = 1
    flag = Array(numrows, sint)
    new_credit = Array(numrows, sint)

    while stepsize < numrows // 2:

        # inc(size, base, step, repeat)
        # produces a regint vector like range(base, size // step, step)
        # get method takes an array of regints and produces the
        # vector indexed by them,

        # flag = helperbits_and_istrigger{stepsize:]
        # credit = reports[: -stepsize][VALUE] + flag * reports[stepsize: ][VALUE]
        stepsize *= 2

        new_size = numrows - stepsize

        @for_range_opt(new_size)
        def _():
            flag = stopbit[ind] * helperbits_and_istrigger[ind + stepsize]

            new_credit[ind] = (credit[ind] + flag
                               * credit[ind + stepsize])

            stopbit[ind] = flag * stopbit[ind + stepsize]

        @for_range_opt(stepsize)
        def _(ind):
            stopbit[ind + new_size] = 0

        @for_range_opt(numrows)
        def _(ind):
            credit[ind] = new_credit[ind]

    # Calculate final_credits
    breakdown = reports.get_column(BREAKDOWN_KEY)

    # Once we have AND, XOR is just addition and subtraction

    helperbits_xor_istrigger = Array(numrows, sint)
    # Note if x,y are 0/1 valued then
    # x XOR y = x + y - 2 * x*y
    @for_range_opt
    def _(ind):
        helperbits_xor_istrigger[ind] = (helperbits[ind] +
                                         reports[ind, IS_TRIGGER]
                                         -2 * helperbits_and_istrigger[ind])
        

    final_credits = helperbits_xor_istrigger * credit
        
    breakdown_keys = list(range(breakdown_values))

    breakdown_key_sums = Array(breakdown_values, sint)

    for breakdown_key in breakdown_keys:

        # max[idx] = 1 if breakdown[idx] == breakdown_key, 0 otherwise
        mask = breakdown == breakdown_key
        # Sum up the final_credits for this breakdown
        # We can do this with sum, but tree_reduce is more efficient.
        breakdown_key_sums[breakdown_key] = tree_reduce(lambda x,y: x + y,
                                                            mask * final_credits)

    return breakdown_key_sums

def main():
    """
    Do the main processing.
    """

    set_directory()
    from asort import bit_radix_sort, radix_sort
    args = get_args(program.args[1: ])
    print(f"args = {args}")

    numrows = 2 ** args.numrows_power

    # load the data

    reports = Matrix(numrows, 4, sint)
    reports.assign_vector(sint.get_input_from(0, size = numrows * 4))

    match_keys = reports.get_column(MATCH_KEYS)
    # Now do the sort
    # Radix sort
    sorter = {LIBRARY_SORT: lambda mkeys, reps:
              sorting.radix_sort(mkeys, reports, n_bits = args.n_bits),
              RADIX_SORT: lambda mkeys, reps:
              radix_sort(mkeys, reps, n_bits = args.n_bits),
              BATCHER_SORT: lambda mkeys, reps:
              print("Batcher not implemented")}

    if args.do_sort:

        sort_fn = sorter.get(args.sort_type,
                             lambda mkeys, reps:
                             print(f"Illegal sort type {args.sort_type}"))
        sort_fn(reports.get_column(MATCH_KEYS), reports)

    breakdown_key_sums = oblivious_attribution(reports,
                                               args.breakdown_values)
    print_ln("breakdowns: %s", breakdown_key_sums.reveal())
    
main()

